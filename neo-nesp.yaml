substitutions:
  friendly_name: 'HAL 9000'
  hostname: 'hal9000'
  device_name: 'HAL 9000'
  device_description: 'waveshare-esp32-s3-touch-lcd-2.1' 
  #ip: 10.0.80.75
  min_thermostat_temp: 13.0
  max_thermostat_temp: 30.0
  # Home Assistant entities you want to control with HAL9000
  climate_entity: climate.climate_control
  time_zone: 'Australia/Melbourne'
  default_brightness: 0.29  # conservative brightness

esphome:
  name: ${hostname}
  name_add_mac_suffix: true
  friendly_name: ${friendly_name}
  comment: ${device_description}
  platformio_options:
    board_build.flash_mode: dio
    board_build.arduino.memory_type: qio_opi
  on_boot:
    - lambda: id(hal).set_supports_heat_cool(false);  # disable heat/cool for this use case.
    - light.turn_on:
        id: backlight
        brightness: ${default_brightness} #0.5
    - pcf85063.read_time:

esp32:
  board: esp32-s3-devkitc-1
  flash_size: 8MB
  variant: esp32s3
  framework:
    type: esp-idf
    sdkconfig_options:
      CONFIG_ESPTOOLPY_FLASHFREQ: "80MHz" # this is needed for flashing
      CONFIG_ESPTOOLPY_FLASHMODE_QIO: y
      CONFIG_FLASHMODE_QIO: y
      CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ_240: y
      CONFIG_ESP_DEFAULT_CPU_FREQ_MHZ: '240'
      CONFIG_SPIRAM_RODATA: "y"
      CONFIG_COMPILER_OPTIMIZATION : performance
      CONFIG_LWIP_MAX_SOCKETS: "20"

psram:
  mode: octal
  speed: 80MHz
  
# I2C bus configuration
i2c:
  - id: i2c_bus
    sda: GPIO15
    scl: GPIO07
    frequency: 200kHz #400kHz #300kHz  # conservative as cable is 3m long

# PCA9554 GPIO extender for display reset
pca9554:
  - id: p_c_a
    address: 0x20
    i2c_id: i2c_bus
  - id: pca9535_device  # Relay board
    address: 0x24
    pin_count: 16

debug:
  update_interval: 60s

<<: !include _common.yaml

# Buzzer, Backlight PWM output and light component
output:
    # Backlight LED
  - platform: ledc
    pin: GPIO06
    id: display_led   #GPIO06  #
    frequency: 2000Hz
    channel: 0

light:
  - platform: monochromatic
    output: display_led 
    name: Backlight
    id: backlight
    internal: true # adjusting slider kills time out functionality so hide from UI.
    restore_mode: ALWAYS_ON
    icon: mdi:brightness-percent
    default_transition_length: 500ms
    gamma_correct: 1

# Example dual-point configuration entry 
climate:
  - platform: thermostat
    name: "Thermostat Climate Controller"
    id: hal
    sensor: room_temperature
    humidity_sensor: room_humidity
    visual:
      temperature_step: 0.5 °C
      min_temperature: ${min_thermostat_temp} #13.0 # °C
      max_temperature: ${max_thermostat_temp} #30.0 # °C
            
    min_heating_off_time: 180s #30s #300s
    min_heating_run_time: 180s #30s #300s
    min_cooling_off_time: 180s #30s #300s
    min_cooling_run_time: 180s #30s #300s
    min_fanning_off_time: 180s #30s #300s
    min_fanning_run_time: 180s #30s #300s
    min_idle_time: 30s
    heat_deadband: 0.5 
    heat_overrun: 0.5
    target_temperature_change_action:
      - lambda: |-
         if(!isnan(id(hal).current_temperature)) id(update_roller_needle_and_arc).execute();

    cool_action:
      - lambda: ESP_LOGD("cool_action!", "");
      - switch.turn_on: cool 
      - switch.turn_on: fan
      - switch.turn_off: heat
      - lambda: |- 
          id(set_mode_cool).execute();
    heat_action:
      - lambda: ESP_LOGD("heat_action!", "");
      - switch.turn_on: heat
      - switch.turn_off: cool 
      - switch.turn_off: fan  # Heater auto activates fan
      - lambda: |-
          id(set_mode_heat).execute();
    idle_action:
      - lambda: ESP_LOGD("idle_action!", "");
      - switch.turn_off: heat
      - switch.turn_off: cool
      - switch.turn_off: fan
      - lambda: id(set_mode_idle).execute();
    fan_only_action:
      - lambda: ESP_LOGD("fan_action!", "");
      - switch.turn_on: fan
      - switch.turn_off: heat
      - switch.turn_off: cool 
      - lambda: id(set_mode_fan).execute();
    off_mode:
      - lambda: ESP_LOGD("off_action!", "");
      - switch.turn_off: heat
      - switch.turn_off: cool
      - switch.turn_off: fan
      - lambda: id(set_mode_off).execute();
#    on_control:
#      - logger.log: "Control input received; configuration updated!" 
#
#  Catch all for HA actions.
#
    on_state:
      #- logger.log: "State updated!"
      #- lambda: ESP_LOGD("on_state!", ""); 
      - lambda: |-
          if (x.mode == CLIMATE_MODE_HEAT) {
            //ESP_LOGD("on_state_heat!", "");
              if(id(hal).target_temperature_high != ${max_thermostat_temp})
                id(hal).target_temperature_high = ${max_thermostat_temp};  // Set not applicable setpoint to max
              id(set_mode_heat).execute();
          }
          if (x.mode == CLIMATE_MODE_COOL) {
            //ESP_LOGD("on_state_cool!", "");
            if(id(hal).target_temperature_low != ${min_thermostat_temp})
              id(hal).target_temperature_low = ${min_thermostat_temp};   // Set not applicable setpoint to min
            id(set_mode_cool).execute();
          }
          if (x.mode == CLIMATE_MODE_FAN_ONLY) {
            //ESP_LOGD("on_state_fan!", "");
            id(set_mode_fan).execute();
          }
          if(id(hal).action == CLIMATE_ACTION_OFF && id(hal).mode == CLIMATE_MODE_OFF)
            id(set_mode_off).execute(); 
             
    default_preset: Home
    preset:
      - name: Home
        default_target_temperature_low: 20 °C
        default_target_temperature_high: 22 °C  
        
switch:
# Buzzer
  - platform: gpio
    pin:
      pca9554: p_c_a
      number: 7
    id: buzzer
    name: "Buzzer"
    internal: true
    on_turn_on:
    - delay: 50ms
    - switch.turn_off: buzzer
# Relays
  - platform: gpio
    name: "Pin #A0 Heat"
    id: heat
    pin:
      pca9554: pca9535_device
      number: 0
      mode:
        output: true
      inverted: false
  - platform: gpio
    name: "Pin #A1 Cool"
    id: cool
    pin:
      pca9554: pca9535_device
      number: 1
      mode:
        output: true
      inverted: false
  - platform: gpio
    name: "Pin #A2 Fan"
    id: fan
    pin:
      pca9554: pca9535_device
      number: 2
      mode:
        output: true
      inverted: false
  - platform: gpio
    name: "Pin #A3 Spare"
    id: spare
    pin:
      pca9554: pca9535_device
      number: 3
      mode:
        output: true
      inverted: false     
  ### DISPLAY ANTI BURN-IN
  - platform: template
    name: Antiburn
    id: switch_antiburn
    icon: mdi:television-shimmer
    optimistic: true
    internal: true
    turn_on_action:
      - logger.log: "Starting Antiburn"
      - light.turn_off: backlight
      - if:
          condition: lvgl.is_paused
          then:
            - lvgl.resume:
            - lvgl.widget.redraw:
            - delay: 1s
      - lvgl.pause:
          show_snow: true
    turn_off_action:
      - logger.log: "Stopping Antiburn"
      - if:
          condition: lvgl.is_paused
          then:
            - lvgl.resume:
            - lvgl.widget.redraw:
            - delay: 1s
            - lvgl.pause:
      
time:
  - platform: sntp
    id: sntp_time
    timezone: ${time_zone} #"Australia/Melbourne"
    on_time_sync:
     # ... and update the RTC when the synchronization was successful
     - pcf85063.write_time: 
     
  - platform: pcf85063
    id: pcf85063_time
    update_interval: never
    on_time:
      #- seconds: /5 #0 #/5 #0
      - seconds: /60 #0 #/5 #0
        then:
          - lambda: |-
              //static const char* TAG = "Temps";
              //ESP_LOGI(TAG, "target: %.1f target_low: %.1f target_high: %.1f h: %.1f c: %.1f", id(hal).target_temperature, id(hal).target_temperature_low, id(hal).target_temperature_high, id(my_target_temp_heat), id(my_target_temp_cool));
              //ESP_LOGI(TAG, "target: %.1f target_low: %.1f target_high: %.1f", id(hal).target_temperature, id(hal).target_temperature_low, id(hal).target_temperature_high);
              static const char* TAG_SNTP = "SNTP Time";
              static char time_str[30];
              time_t now = id(sntp_time).now().timestamp;
              strftime(time_str, sizeof(time_str), "%Y-%m-%d %H:%M:%S", localtime(&now));
              ESP_LOGI(TAG_SNTP, "%s", time_str);
              static const char* TAG_RTC = "RTC Time";
              now = id(pcf85063_time).now().timestamp;
              strftime(time_str, sizeof(time_str), "%Y-%m-%d %H:%M:%S", localtime(&now));
              ESP_LOGI(TAG_RTC, "%s", time_str);
              
      - hours: 2,3,4,5
        minutes: 5
        seconds: 0
        then:
          - switch.turn_on: switch_antiburn
      - hours: 2,3,4,5
        minutes: 35
        seconds: 0
        then:
          - switch.turn_off: switch_antiburn

button:
- platform: restart
  name: Restart
  disabled_by_default: True

sensor:
  - platform: uptime
    name: Uptime
    disabled_by_default: True

  - platform: htu31d 
    update_interval: 15s #10s #20s # How often to update the sensor readings
    temperature:
      name: "Room Temperature"
      id: room_temperature
      unit_of_measurement: "°C"
      accuracy_decimals: 1
      filters:
        - filter_out: nan
      on_value:
        then:
          - script.execute: update_menu_temp_label
          - lambda: if(!isnan(id(hal).current_temperature)) id(update_roller_needle_and_arc).execute();
#          - lambda: |
#              if(id(room_temperature).is_heater_enabled()) 
#                ESP_LOGD("heater on!", "");
#              else
#                ESP_LOGD("heater off!", "");
              
    humidity:
      name: "Room Humidity"
      id: room_humidity
      unit_of_measurement: "%"
      accuracy_decimals: 1
      filters:
        - filter_out: nan
   
text_sensor:
#  - platform: template
#    id: current_time_sensor
#    name: "Current SNTP Time"
#    internal: true
#    lambda: |
#      static char time_str[30];
#      time_t now = id(sntp_time).now().timestamp;
#      strftime(time_str, sizeof(time_str), "%Y-%m-%d %H:%M:%S", localtime(&now));
#      return (std::string) time_str;
#    update_interval: never # 60s # Update the sensor every 60 seconds
#    
#  - platform: template
#    id: current_RTC_time_sensor
#    name: "Current RTC Time"
#    internal: true
#    lambda: |
#      static char time_str[30];
#      time_t now = id(pcf85063_time).now().timestamp;
#      strftime(time_str, sizeof(time_str), "%Y-%m-%d %H:%M:%S", localtime(&now));
#      return (std::string) time_str;
#    update_interval: never #60s # Update the sensor every 60 seconds
          
############  Debugging...
  - platform: template
    id: temp_heat
    name: "Last Heat Temp"
    lambda: |
      return str_sprintf("%.1f", id(last_target_temp_heat));
    update_interval: 60s # Update the sensor every 60 seconds 
    
  - platform: template
    id: temp_cool
    name: "Last Cool Temp"
    lambda: |
      return str_sprintf("%.1f", id(last_target_temp_cool));
    update_interval: 60s # Update the sensor every 60 seconds       

  - platform: debug
    reset_reason:
      name: Reset Reason
      disabled_by_default: True

# SPI bus configuration
spi:
  - id: spi_lcd
    clk_pin: GPIO02
    mosi_pin: GPIO01
    interface: spi3

display:
  - platform: st7701s
    id: screen
    spi_mode: MODE0
    data_rate: 40Mhz #10MHz # 40Mhz
    color_order: RGB
    auto_clear_enabled: false
    update_interval: never
    dimensions:
      width: 480
      height: 480
    cs_pin:
      pca9554: p_c_a
      number: 2
    reset_pin:
      pca9554: p_c_a
      number: 0
    de_pin: GPIO40
    hsync_pin: GPIO38
    vsync_pin: GPIO39
    pclk_pin: GPIO41
    #ignore_strapping_warning: true
    pclk_frequency: 16Mhz #15Mhz #30MHz  VERY Important to set to 16Mhz otherwise get tearing.
    pclk_inverted: false
    hsync_pulse_width: 8 #10
    hsync_back_porch:  10
    hsync_front_porch: 50 #10 
    vsync_pulse_width:  3 #2
    vsync_back_porch:  8 #12
    vsync_front_porch: 8 #14
    data_pins:
      red:
        - 46       #r1
        - 3        #r2
        - 8        #r3
        - 18       #r4
        - 17       #r5
      green:
        - 14       #g0
        - 13       #g1
        - 12       #g2
        - 11       #g3
        - 10       #g4
        - 9        #g5
      blue:
        - 5        #b1
        - 45       #b2
        - 48       #b3
        - 47       #b4
        - 21       #b5
    init_sequence:
      # Reference: wireless-tag sample code: 
      # https://github.com/wireless-tag-com/ZX2D10GE01R-V4848/blob/master/main/screen.c
      - [0xFF, 0x77, 0x01, 0x00, 0x00, 0x13]    # CMD2_BKSEL (command bank select BK3, BK func enabled)
      - [0xEF, 0x08]
      - [0xFF, 0x77, 0x01, 0x00, 0x00, 0x10]    # CMD2_BKSEL (command bank select BK0, BK func disabled)
      - [0xC0, 0x3B, 0x00]                      # Scan line
      - [0xC1, 0x0B, 0x02]                      # VBP
      - [0xC2, 0x07, 0x02]
      - [0xCC, 0x10]
      - [0xCD, 0x08]                            # RGB format | ?565??? 666??
      - [0xB0, 0x00, 0x11, 0x16, 0x0e, 0x11, 0x06, 0x05, 0x09, 0x08, 0x21, 0x06, 0x13, 0x10, 0x29, 0x31, 0x18]   # IPS | 255 | 251 | 247 down | 239 | 231 | 203 | 175 | 147 | 108 | 80 | 52 | 24 | 16 | 8 down | 4 | 0
      - [0xB1, 0x00, 0x11, 0x16, 0x0e, 0x11, 0x07, 0x05, 0x09, 0x09, 0x21, 0x05, 0x13, 0x11, 0x2a, 0x31, 0x18]   # IPS | 255 | 251 | 247 down | 239 | 231 | 203 | 175 | 147 | 108 | 80 | 52 | 24 | 16 | 8 down | 4 | 0
      - [0xFF, 0x77, 0x01, 0x00, 0x00, 0x11]
      - [0xB0, 0x6d]                            # VOP  3.5375+ *x 0.0125 | 5D
      - [0xB1, 0x37]                            # VCOM amplitude setting
      - [0xB2, 0x81]                            # VGH Voltage setting | 12V
      - [0xB3, 0x80]
      - [0xB5, 0x43]                            # VGL Voltage setting | -8.3V
      - [0xB7, 0x85]
      - [0xB8, 0x20]
      - [0xC1, 0x78]
      - [0xC2, 0x78]
      - [0xD0, 0x88]
      - [0xE0, 0x00, 0x00, 0x02]
      - [0xE1, 0x03, 0xA0, 0x00, 0x00, 0x04, 0xA0, 0x00, 0x00, 0x00, 0x20, 0x20]
      - [0xE2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
      - [0xE3, 0x00, 0x00, 0x11, 0x00]
      - [0xE4, 0x22, 0x00]
      - [0xE5, 0x05, 0xEC, 0xA0, 0xA0, 0x07, 0xEE, 0xA0, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
      - [0xE6, 0x00, 0x00, 0x11, 0x00]
      - [0xE7, 0x22, 0x00]
      - [0xE8, 0x06, 0xED, 0xA0, 0xA0, 0x08, 0xEF, 0xA0, 0xA0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
      - [0xEB, 0x00, 0x00, 0x40, 0x40, 0x00, 0x00, 0x00]
      - [0xED, 0xFF, 0xFF, 0xFF, 0xBA, 0x0A, 0xBF, 0x45, 0xFF, 0xFF, 0x54, 0xFB, 0xA0, 0xAB, 0xFF, 0xFF, 0xFF]
      - [0xEF, 0x10, 0x0D, 0x04, 0x08, 0x3F, 0x1F]
      - [0xFF, 0x77, 0x01, 0x00, 0x00, 0x13]    # CMD2_BKSEL (command bank select BK3, BK func enabled)
      - [0xEF, 0x08]
      - [0xFF, 0x77, 0x01, 0x00, 0x00, 0x00]    # CMD2_BKSEL (command bank select BK0, BK func disabled)
      - [0x36, 0x00]                            # MADCTL_CMD (already in esphome ST7701S::write_init_sequence_)
      - [0x3A, 0x66]                            # COLMOD 55/50=16bit(RGB565); 66=18bit(RGB666); 77?????3AH?=24bit(RGB888)
      # - [0x11]                                  # SLEEP_OUT (already in esphome)
      # - delay 120ms
      # - [0x29]                                  # DISPLAY_ON (already in esphome)
      # - delay 20ms
      #

# CST820 Touchscreen Controller
touchscreen:
  - platform: cst816
    calibration:
      x_min: 0
      x_max: 430  # touchscreen is non linear on LHS!  This is the best compromise for my device.
      y_min: 0
      y_max: 480
    id: my_touchscreen
    i2c_id: i2c_bus
    reset_pin:
      pca9554: p_c_a
      number: 1
    interrupt_pin: GPIO16
#    on_update:
#      - lambda: |-
#            for (auto touch: touches)  {
#                if (touch.state <= 2) {
#                  ESP_LOGI("Touch points:", "id=%d x=%d, y=%d", touch.id, touch.x, touch.y);
#                }
#            }

    on_release:
      - if:
          condition: lvgl.is_paused
          then:
            - logger.log: "LVGL resuming"
            - lvgl.resume:
            - lvgl.widget.redraw:
            - light.turn_on: 
                id: backlight
                brightness: ${default_brightness} #50%
                
#    on_touch:
#     - lambda: |-
#          ESP_LOGI("cal", "x=%d, y=%d, x_raw=%d, y_raw=%0d",
#              touch.x,
#              touch.y,
#              touch.x_raw,
#              touch.y_raw
#              );  

number:
  - platform: template
    name: LVGL Screen timeout
    optimistic: true
    id: display_timeout
    unit_of_measurement: "s"
    initial_value: 45
    restore_value: true
    min_value: 10
    max_value: 180
    step: 5
    mode: box


    
<<: !include _neo-nesp_UI.yaml
<<: !include schedule.yaml
# Only include binary_sensors.yaml if you need to correct touchscreen
# non-linearities.
<<: !include binary_sensors.yaml  


      


      




